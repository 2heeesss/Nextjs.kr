---
title: redirects
description: Next.js 앱에 `redirects`를 추가하세요.
---

Redirects allow you to redirect an incoming request path to a different destination path.

`Redirects`는 들어오는 요청을 다른 대상 경로로 리다이렉트하는 기능입니다.

To use redirects you can use the `redirects` key in `next.config.js`:

`redirects`를 쓰기 위해 `next.config.js` 에서 `redirects` 속성을 사용하세요.

```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
    ]
  },
}
```

`redirects` is an async function that expects an array to be returned holding objects with `source`, `destination`, and `permanent` properties:

`redirects`는 배열을 반환하는 것으로 예상하는 비동기 함수입니다. 이 배열은 `source`, `destination`, `permanent` 속성을 가진 객체들을 가져야 합니다.

<!-- - `source` is the incoming request path pattern. -->
- `source`는 들어오는 요청에 대한 경로 패턴입니다.
<!-- - `destination` is the path you want to route to. -->
- `destination`은 원하는 라우트에 대한 경로입니다.
<!-- - `permanent` `true` or `false` - if `true` will use the 308 status code which instructs clients/search engines to cache the redirect forever, if `false` will use the 307 status code which is temporary and is not cached. -->
- `permanent` `true` 또는 `false` - `true`라면 308 상태 코드를 사용하여 클라이언트 및 검색 엔진이 영구적으로 리다이렉트하도록 하며, `false` 라면 307 상태 코드를 사용하여 임시로 처리하고 캐시되지 않습니다.

> **Why does Next.js use 307 and 308?** Traditionally a 302 was used for a temporary redirect, and a 301 for a permanent redirect, but many browsers changed the request method of the redirect to `GET`, regardless of the original method. For example, if the browser made a request to `POST /v1/users` which returned status code `302` with location `/v2/users`, the subsequent request might be `GET /v2/users` instead of the expected `POST /v2/users`. Next.js uses the 307 temporary redirect, and 308 permanent redirect status codes to explicitly preserve the request method used.

> **Next.js는 왜 307과 308 상태 코드를 사용하나요?** 전통적으로 302 상태 코드는 임시로 리다이렉트하기 위해 사용되어왔고, 301 상태 코드는 영구적으로 리다이렉트하기 위해 사용되었습니다. 그러나 많은 브라우저들이 원래 메소드와는 상관없이 리다이렉트의 요청 메소드를 `GET`으로 변경했습니다. 예를 들어 브라우저가 `POST /v1/users` 로 요청을 보내고 이에 대한 리스폰스로 302 상태 코드와 `/v2/users` 를 받았을 때, 그 다음 요청은 `POST /v2/users` 대신 `GET/v2/users`일 수 있습니다. Next.js는 요청에 사용된 메소드를 명시적으로 보존하기 위해 307 임시 리다이렉트와 308 영구 리다이렉트 상태 코드를 사용합니다.

<!-- - `basePath`: `false` or `undefined` - if false the `basePath` won't be included when matching, can be used for external redirects only. -->
- `basePath` : `false` 또는 `undefined` - `false`라면 `basePath`는 일치하는 경우에 포함되지 않으며, 외부로 리다이렉트할때만 사용합니다.

<!-- - `locale`: `false` or `undefined` - whether the locale should not be included when matching. -->
- `locale`: `false` 또는 `undefined` - 일치하는 경우에 `locale`을 포함하지 않아야 하는지 여부에 대한 것입니다.

<!-- - `has` is an array of [has objects](#header-cookie-and-query-matching) with the `type`, `key` and `value` properties. -->
- `has`는 `type`, `key`, `value` 속성과 함께 사용하는 [`has` 객체](#header-cookie-and-query-matching)의 배열입니다.

<!-- - `missing` is an array of [missing objects](#header-cookie-and-query-matching) with the `type`, `key` and `value` properties. -->

- `missing`는 `type`, `key`, `value` 속성과 함께 사용하는 [`missing` 객체](#header-cookie-and-query-matching)의 배열입니다.

<!-- Redirects are checked before the filesystem which includes pages and `/public` files. -->

`Redirects`는 `pages`와 `/public` 파일을 포함하는 파일시스템 이전에 확인합니다.

Redirects are not applied to client-side routing (`Link`, `router.push`), unless [Middleware](/docs/app/building-your-application/routing/middleware) is present and matches the path.

`Redirects`는 [미들웨어](/docs/app/building-your-application/routing/middleware)가 존재하고 경로와 일치하지 않는 한 클라이언트 측 라우팅을 적용하지 않습니다.

When a redirect is applied, any query values provided in the request will be passed through to the redirect destination. For example, see the following redirect configuration:

`redirect`를 적용하면, 요청 안에 있는 모든 쿼리 값은`redirect` 대상으로부터 전달됩니다.
예를 들어, 다음과 같은 리다이렉트 설정을 참고하세요.

```js
{
  source: '/old-blog/:path*',
  destination: '/blog/:path*',
  permanent: false
}
```

When `/old-blog/post-1?hello=world` is requested, the client will be redirected to `/blog/post-1?hello=world`.

`/old-blog/post-1?hello=world`로 요청을 하면, 클라이언트는 `/blog/post-1?hello=world`로 리다이렉트합니다. 

## Path Matching

## 경로 매칭

Path matches are allowed, for example `/old-blog/:slug` will match `/old-blog/hello-world` (no nested paths):

경로 일치는 허용됩니다. 예를 들어 `/old-blog/:slug`는 `/old-blog/hello-world`와 일치합니다.(중첩된 경로는 없음)

```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/news/:slug', // 일치하는 매개변수는 destination에서 사용할수 있습니다.
        permanent: true,
      },
    ]
  },
}
```

### 와일드카드 경로 일치

<!-- To match a wildcard path you can use `*` after a parameter, for example `/blog/:slug*` will match `/blog/a/b/c/d/hello-world`: -->

와일드카드 경로와 일치시키려면, 파라미터 뒤에 `*`를 사용하세요. 예를 들어 `/blog/:slug*`는 `/blog/a/b/c/d/hello-world`와 일치합니다.

```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*', // 일치하는 매개변수는 destination에서 사용할수 있습니다.
        permanent: true,
      },
    ]
  },
}
```

### Regex Path Matching

### 정규식 경로 매칭

To match a regex path you can wrap the regex in parentheses after a parameter, for example `/post/:slug(\\d{1,})` will match `/post/123` but not `/post/abc`:

정규식 경로와 일치시키려면 파라미터 뒤에 괄호로 정규식을 감싸면 됩니다. 예를 들어 `/post/:slug(\\d{1,})`은 `/post/123`과는 일치하지만 `/post/abc`와는 일치하지 않습니다.

```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      {
        source: '/post/:slug(\\d{1,})',
        destination: '/news/:slug', // 일치하는 매개변수는 destination에서 사용할수 있습니다.
        permanent: false,
      },
    ]
  },
}
```

<!-- The following characters `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` are used for regex path matching, so when used in the `source` as non-special values they must be escaped by adding `\\` before them: -->

다음으로 오는 문자 `(`, `)`, `{`, `}`, `:`, `*`, `+`, `?` 는 정규식 매칭을 위해 사용하기 때문에 `source`에서 특수하지 않은 값으로 사용할 때는 앞에 `\\`로 이스케이프 처리해야 합니다.


```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      {
        // `source`는 `/english(default)/something`과 일치합니다.
        source: '/english\\(default\\)/:slug',
        destination: '/en-us/:slug',
        permanent: false,
      },
    ]
  },
}
```

<!-- ## Header, Cookie, and Query Matching -->

## 헤더, 쿠키, 쿼리 매칭

To only match a redirect when header, cookie, or query values also match the `has` field or don't match the `missing` field can be used. Both the `source` and all `has` items must match and all `missing` items must not match for the redirect to be applied.

헤더, 쿠키 또는 쿼리 값이 `has` 필드와 일치하거나 `missing` 필드와 일치하지 않는 경우에만 `redirect`를 일치시킵니다. `redirect`를 적용하기 위해서 `source` 와 모든 `has` 항목이 모두 일치해야 하며 모든 `missing` 항목이 일치하지 않아야 합니다.


<!-- `has` and `missing` items can have the following fields: -->

`has`와 `missing` 항목은 다음과 같은 필드를 가집니다.

- `type`: `String` - must be either `header`, `cookie`, `host`, or `query`.
- `key`: `String` - the key from the selected type to match against.
- `value`: `String` or `undefined` - the value to check for, if undefined any value will match. A regex like string can be used to capture a specific part of the value, e.g. if the value `first-(?<paramName>.*)` is used for `first-second` then `second` will be usable in the destination with `:paramName`.

- `type`: `String` - `header`, `cookie`, `host` 또는 `query`여야 합니다.
- `key`: `String` - 선택한 타입에 대해 일치시킬 key입니다.
- `value`: `String` 또는 `undefined` - 확인할 값으로, `undefined`이라면 모든 값에 대해 일치합니다. 정규 표현식과 유사한 문자열을 사용하여 value의 특정 부분을 캡처할 수 있습니다. 예를 들어, `first-(?<paramName>.*)`가 `first-second`에 사용되면 `second`는 `:paramName`에 사용할 수 있습니다.

```js filename="next.config.js"
module.exports = {
  async redirects() {
    return [
      // `x-redirect-me` 헤더가 존재하면
      // 이 헤더는 리다이렉트됩니다.
      {
        source: '/:path((?!another-page$).*)',
        has: [
          {
            type: 'header',
            key: 'x-redirect-me',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
      // `x-dont-redirect` 헤더가 존재하면
      // 이 헤더는 리다이렉트 되지 않습니다.
      {
        source: '/:path((?!another-page$).*)',
        missing: [
          {
            type: 'header',
            key: 'x-do-not-redirect',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
      // source, query, cookie가 일치하면
      // 리다이렉트됩니다.
      {
        source: '/specific/:path*',
        has: [
          {
            type: 'query',
            key: 'page',
            // `page` 값은 `destination`에서 사용할 수 없습니다.
            // 이 값이 제공되고 지정된 캡처 그룹(e.g. ?<page>home)을 사용하지 않기 때문입니다.
            value: 'home',
          },
          {
            type: 'cookie',
            key: 'authorized',
            value: 'true',
          },
        ],
        permanent: false,
        destination: '/another/:path*',
      },
      // if the header `x-authorized` is present and
      // contains a matching value, this redirect will be applied

      // `x-authorized`가 존재하고
      // 일치하는 값이 포함되면, 리다이렉트됩니다.
      {
        source: '/',
        has: [
          {
            type: 'header',
            key: 'x-authorized',
            value: '(?<authorized>yes|true)',
          },
        ],
        permanent: false,
        destination: '/home?authorized=:authorized',
      },
      // if the host is `example.com`,
      // this redirect will be applied

      // 호스트가 `example.com`이라면
      // 리다이렉트됩니다.
      {
        source: '/:path((?!another-page$).*)',
        has: [
          {
            type: 'host',
            value: 'example.com',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
    ]
  },
}
```

### Redirects with basePath support

### `basePath`를 지원하는 Redirects

When leveraging [`basePath` support](/docs/app/api-reference/next-config-js/basePath) with redirects each `source` and `destination` is automatically prefixed with the `basePath` unless you add `basePath: false` to the redirect:

`redirects` 에서 [`basePath` 지원](/docs/app/api-reference/next-config-js/basePath)을 활용할 때 각 `source`와 `destination`은 redirect에 `basePath: false`를 추가하지 않는 이상 `basePath`로 접두사가 자동으로 붙습니다. 

```js filename="next.config.js"
module.exports = {
  basePath: '/docs',

  async redirects() {
    return [
      {
        source: '/with-basePath', // 자동으로 /docs/with-basePath로 변합니다.
        destination: '/another', // 자동으로 /docs/another로 변합니다.
        permanent: false,
      },
      {
        // basePath: false 이기 때문에 /docs를 붙이지 않습니다.
        source: '/without-basePath',
        destination: 'https://example.com',
        basePath: false,
        permanent: false,
      },
    ]
  },
}
```

### Redirects with i18n support

When leveraging [`i18n` support](/docs/pages/building-your-application/routing/internationalization) with redirects each `source` and `destination` is automatically prefixed to handle the configured `locales` unless you add `locale: false` to the redirect. If `locale: false` is used you must prefix the `source` and `destination` with a locale for it to be matched correctly.

```js filename="next.config.js"
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
  },

  async redirects() {
    return [
      {
        source: '/with-locale', // automatically handles all locales
        destination: '/another', // automatically passes the locale on
        permanent: false,
      },
      {
        // does not handle locales automatically since locale: false is set
        source: '/nl/with-locale-manual',
        destination: '/nl/another',
        locale: false,
        permanent: false,
      },
      {
        // this matches '/' since `en` is the defaultLocale
        source: '/en',
        destination: '/en/another',
        locale: false,
        permanent: false,
      },
      // it's possible to match all locales even when locale: false is set
      {
        source: '/:locale/page',
        destination: '/en/newpage',
        permanent: false,
        locale: false,
      }
      {
        // this gets converted to /(en|fr|de)/(.*) so will not match the top-level
        // `/` or `/fr` routes like /:path* would
        source: '/(.*)',
        destination: '/another',
        permanent: false,
      },
    ]
  },
}
```

In some rare cases, you might need to assign a custom status code for older HTTP Clients to properly redirect. In these cases, you can use the `statusCode` property instead of the `permanent` property, but not both. To to ensure IE11 compatibility, a `Refresh` header is automatically added for the 308 status code.

드문 경우에, 오래된 HTTP 클라이언트에 대해 올바른 리다이렉트을 위해 사용자 정의 상태 코드를 지정해야 할 수도 있습니다. 이러한 경우 `permanent` 속성 대신 `statusCode` 속성을 사용할 수 있지만 둘 다 사용할 수는 없습니다. IE11 호환성을 위해서 308 상태 코드에 대해 `Refresh` 헤더가 추가됩니다.

## Other Redirects

<!-- - Inside [API Routes](/docs/pages/api-reference/functions/next-server), you can use `res.redirect()`. -->
- [API 라우트](/docs/pages/api-reference/functions/next-server)에서 `res.redirect()`를 사용할 수 있습니다.
- Inside [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) and [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props), you can redirect specific pages at request-time.
- [`getStaticProps`](/docs/pages/building-your-application/data-fetching/get-static-props) 와  [`getServerSideProps`](/docs/pages/building-your-application/data-fetching/get-server-side-props)에서 요청할 때 특정한 페이지를 리다이렉트할 수 있습니다.

## Version History

| Version   | Changes            |
| --------- | ------------------ |
| `v13.3.0` | `missing` 추가.   |
| `v10.2.0` | `has` 추가.       |
| `v9.5.0`  | `redirects` 추가. |
