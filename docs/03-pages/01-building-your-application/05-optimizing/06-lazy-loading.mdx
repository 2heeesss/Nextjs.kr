---
title: Lazy Loading
description: 불러온 라이브러리와 React 컴포넌트를 Lazy load해서 애플리케이션의 로드 성능을 향상시킵니다.
source: app/building-your-application/optimizing/lazy-loading
---

Next.js의 [Lazy loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading)은 경로를 렌더링하는 데 필요한 JavaScript의 양을 줄임으로써 애플리케이션의 초기 로드 성능을 향상합니다.

**클라이언트 컴포넌트**와 불러온 라이브러리의 로드를 연기하고 필요한 경우에만 클라이언트 번들에 포함할 수 있습니다. 예를 들어, 사용자가 모달을 열기 위해 클릭할 때까지 모달을 로드하는 것을 연기할 수 있습니다.

Next.js에서 Lazy Loading을 구현할 수 있는 두 가지 방법은 다음과 같습니다.

1. `next/dynamic`으로 Dynamic Imports을 사용하는 방법
2. [Suspense](https://react.dev/reference/react/Suspense) 컴포넌트와 [`React.lazy()`](https://react.dev/reference/react/lazy)를 사용하는 방법

기본적으로 서버 컴포넌트는 자동으로 [코드 분할](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)되며, [스트리밍](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)을 사용하여 서버에서 클라이언트로 UI 조각을 점진적으로 전송할 수 있습니다. Lazy loading은 클라이언트 컴포넌트에 적용됩니다.

### `next/dynamic`

`next/dynamic` 은 [`React.lazy()`](https://react.dev/reference/react/lazy) 와 [Suspense](https://react.dev/reference/react/Suspense) 컴포넌트의 합성물입니다. 점진적 마이그레이션을 허용하기 위해 `app`과 `pages` 디렉터리에서도 동일한 방식으로 작동합니다.

## 예시

`next/dynamic`을 사용하면 헤더 컴포넌트가 페이지의 초기 JavaScript 번들에 포함되지 않습니다. 페이지는 먼저 Suspense `fallback`을 렌더링하고, Suspense 영역이 해결되면 `Header` 컴포넌트를 렌더링합니다.

```jsx
import dynamic from 'next/dynamic'

const DynamicHeader = dynamic(() => import('../components/header'), {
  loading: () => <p>로딩 중...</p>,
})

export default function Home() {
  return <DynamicHeader />
}
```

> **참고**: `import('path/to/component')`에서 경로는 명시적으로 작성해야 합니다. 템플릿 문자열이나 변수로 사용할 수 없습니다. 또한, Next.js가 webpack 번들/모듈 ID를 특정 `dynamic()` 호출에 매칭하고 렌더링하기 전에 미리 로드할 수 있도록 `import()`가 `dynamic()` 호출 내부에 있어야 합니다. `dynamic()`는 React 렌더링 내부에서 사용할 수 없습니다. preloading이 작동하려면 `React.lazy`와 마찬가지로 모듈의 최상위 수준에 표시되어야 합니다.

## Named exports된 요소의 경우

Named export된 요소를 동적으로 불러오려면, [`import()`](https://github.com/tc39/proposal-dynamic-import#example)에 의해 반환된 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)에서 반환할 수 있습니다.

```jsx filename="components/hello.js"
export function Hello() {
  return <p>안녕하세요!</p>
}

// pages/index.js
import dynamic from 'next/dynamic'

const DynamicComponent = dynamic(() =>
  import('../components/hello').then((mod) => mod.Hello)
)
```

## SSR을 사용하지 않는 경우

클라이언트 측에서 컴포넌트를 동적으로 로드하려면 `ssr` 옵션을 사용하여 서버 렌더링을 비활성화할 수 있습니다. 이 기능은 외부 종속성 또는 컴포넌트가 `window`와 같은 브라우저 API에 의존하는 경우에 유용합니다.

```jsx
import dynamic from 'next/dynamic'

const DynamicHeader = dynamic(() => import('../components/header'), {
  ssr: false,
})
```

## 외부 라이브러리를 사용하는 경우

이 예시는 `fuse.js` 외부 라이브러리를 사용하여 퍼지 검색을 수행합니다. 이 모듈은 사용자가 search input 요소에 입력한 경우에만 브라우저에서 로드됩니다.

```jsx
import { useState } from 'react'

const names = ['Tim', 'Joe', 'Bel', 'Lee']

export default function Page() {
  const [results, setResults] = useState()

  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget
          // 동적으로 fuse.js를 로드합니다.
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)

          setResults(fuse.search(value))
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  )
}
```
